{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"The Aviation Library | Framework Introduction What's Aviation? Aviation is a library and partial framework designed for Roblox and is meant to replace the direct usage of RemoteEvent and RemoteFunctions. It helps to keep communication between client and server and vice versa organised and well maintained. Aviation was formerly known as 'hypixel26's Custom RemoteFramework', and is provided to you by Frieda_VI . Why Aviation? Aviation was designed to be used as a remote filler but why use it? Each players have their own set of RemoteObjects, all having a uniform name, and changing properties of the RemoteObject will result in a Player : Kick () . It helps to keep your code organised, efficient and exploit prof. Aviation is not for everyone, I expect people who are good at managing their codes and RemoteEvents|Functions to be using Aviation. while true do RemoteEvent : FireServer (...) end If your game is coded like the code above, that is the overly usage of RemoteEvents|Functions, I'd suggest you stay away from Aviation as this style of coding is not efficient at all and is to be avoided.","title":"Introduction"},{"location":"#the-aviation-library-framework","text":"","title":"The Aviation Library | Framework"},{"location":"#introduction","text":"What's Aviation? Aviation is a library and partial framework designed for Roblox and is meant to replace the direct usage of RemoteEvent and RemoteFunctions. It helps to keep communication between client and server and vice versa organised and well maintained. Aviation was formerly known as 'hypixel26's Custom RemoteFramework', and is provided to you by Frieda_VI . Why Aviation? Aviation was designed to be used as a remote filler but why use it? Each players have their own set of RemoteObjects, all having a uniform name, and changing properties of the RemoteObject will result in a Player : Kick () . It helps to keep your code organised, efficient and exploit prof. Aviation is not for everyone, I expect people who are good at managing their codes and RemoteEvents|Functions to be using Aviation. while true do RemoteEvent : FireServer (...) end If your game is coded like the code above, that is the overly usage of RemoteEvents|Functions, I'd suggest you stay away from Aviation as this style of coding is not efficient at all and is to be avoided.","title":"Introduction"},{"location":"pages/Api/Client/","text":"Client Functions of Aviation Getting the PlayerStructure and Getting RemoteObjects were discussed and explained in #Sever_and_Client . So we'll be basing our understanding from there. Securise Right after obtaining the PlayerObject on the Main Client Runtime, you should call the :Securise method. The Securise method ensure that the RemoteInstances are exploit prof on the ClientSide. local ReplicatedStorage = game : GetService ( \"ReplicatedStorage\" ) local Aviation = require ( ReplicatedStorage : WaitForChild ( \"Aviation\" )) Aviation . Await () local PlayerStructure = Aviation . Structure () PlayerStructure : Securise () Attaching Functions Not all RemoteObjects will have functions attached to them as some will be used to Invoke the server. The method demonstrated is a primitive way to attach functions to remotes is not very efficient when used as such but it can still be used sometimes. :BindToClient() methods takes in a function which will receive arguments sent by the server. As RemoteObjects are two way communication devices they allow the return of data back to the Server. local Aviation = require ( ReplicatedStorage : WaitForChild ( \"Aviation\" )) local PlayerStructure = Aviation . Structure () local Messenger = PlayerStructure : GetRemote ( \"Messenger\" ) Messenger : BindToClient ( function ( Message , ...) print ( Message ) return \"Woah, that's interesting!\" end ) Efficient Attaching Functions Just like the on the Server we have RemoteList , on the client too we have RemoteList . The way to bind functions to RemoteObjects below is the most efficient and recommended way. RemoteList is a table, you can have creation of RemoteObjects and attach functions to them all in a module and provide it to the PlayerObject to consume. The :FromStructure() method takes the RemoteList as argument and binds function to the following RemoteObject. The RemoteList is a table\"Dictionary\", all the indexes are RemoteObject's name and values are functions that are attached to the RemoteObject and called when the RemoteObject is fired from the Server. local Aviation = require ( ReplicatedStorage : WaitForChild ( \"Aviation\" )) Aviation . Await () local PlayerObject = Aviation . Structure () local RemoteList = { FriedaRemote = function ( Message , ...) print ( Message ) return \"Woah, that's interesting!\" end ); } PlayerObject : FromStructure ( RemoteList ) end )","title":"Client"},{"location":"pages/Api/Client/#client-functions-of-aviation","text":"Getting the PlayerStructure and Getting RemoteObjects were discussed and explained in #Sever_and_Client . So we'll be basing our understanding from there.","title":"Client Functions of Aviation"},{"location":"pages/Api/Client/#securise","text":"Right after obtaining the PlayerObject on the Main Client Runtime, you should call the :Securise method. The Securise method ensure that the RemoteInstances are exploit prof on the ClientSide. local ReplicatedStorage = game : GetService ( \"ReplicatedStorage\" ) local Aviation = require ( ReplicatedStorage : WaitForChild ( \"Aviation\" )) Aviation . Await () local PlayerStructure = Aviation . Structure () PlayerStructure : Securise ()","title":"Securise"},{"location":"pages/Api/Client/#attaching-functions","text":"Not all RemoteObjects will have functions attached to them as some will be used to Invoke the server. The method demonstrated is a primitive way to attach functions to remotes is not very efficient when used as such but it can still be used sometimes. :BindToClient() methods takes in a function which will receive arguments sent by the server. As RemoteObjects are two way communication devices they allow the return of data back to the Server. local Aviation = require ( ReplicatedStorage : WaitForChild ( \"Aviation\" )) local PlayerStructure = Aviation . Structure () local Messenger = PlayerStructure : GetRemote ( \"Messenger\" ) Messenger : BindToClient ( function ( Message , ...) print ( Message ) return \"Woah, that's interesting!\" end )","title":"Attaching Functions"},{"location":"pages/Api/Client/#efficient-attaching-functions","text":"Just like the on the Server we have RemoteList , on the client too we have RemoteList . The way to bind functions to RemoteObjects below is the most efficient and recommended way. RemoteList is a table, you can have creation of RemoteObjects and attach functions to them all in a module and provide it to the PlayerObject to consume. The :FromStructure() method takes the RemoteList as argument and binds function to the following RemoteObject. The RemoteList is a table\"Dictionary\", all the indexes are RemoteObject's name and values are functions that are attached to the RemoteObject and called when the RemoteObject is fired from the Server. local Aviation = require ( ReplicatedStorage : WaitForChild ( \"Aviation\" )) Aviation . Await () local PlayerObject = Aviation . Structure () local RemoteList = { FriedaRemote = function ( Message , ...) print ( Message ) return \"Woah, that's interesting!\" end ); } PlayerObject : FromStructure ( RemoteList ) end )","title":"Efficient Attaching Functions"},{"location":"pages/Api/Server/","text":"Server Functions of Aviation Basic Configuration Server scripts using Aviation should require and .await() until it starts. You would usually want to dedicate an entire server script just for the creation of RemoteObjects and in that script, you should call the .Start() method on Aviation . --// Aviation runner dedicated to creating RemoteEvents \\\\-- local Players = game : GetService ( \"Players\" ) local ReplicatedStorage = game : GetService ( \"ReplicatedStorage\" ) local Aviation = require ( ReplicatedStorage : WaitForChild ( \"Aviation\" )) Aviation . Start () The .Start() method should only be called ONCE by a ServerScript. It's meant to initialise core compoenents of Aviation and to get it to run thus marking it's name to start . --// Random Server Script \\\\-- local Aviation = require ( ReplicatedStorage : WaitForChild ( \"Aviation\" )) Aviation . Await () All ServerScripts using Aviation SHOULD call the .Await() function on Aviation to ensure that everything has been correctly loaded. The Await method will yield until the Start method has been called on Aviation by a ServerScript. RemoteObject Creation RemoteObjects are two way conversation objects meaning they inherrit from RemoteFunctions directly. The creation of RemoteObjects should be wrapped by the .PlayerAdded event, and it is one of the most important features that the Server provides.The examples below assumes that we are using the code above demonstrating how to start Aviation In order to creat RemoteObjects, we need an AviationObject on which RemoteObject creation can be performed. AviationObject Creation Aviation.new() takes 2 arguments, the Player and an optional argument which consists of the Remote name that will be used by all the RemoteFunction instance. The Aviation constructor ( Aviation.new() ) returns an AviationObject(PlayerObject). Right after creating and attaching functions to the AviationObject | PlayerObject , you're required to call the :Process() method on the AviationObject to ensure that it's processed and can used by the client. Since the AviationObject is dedicated to a Player, we can call it a PlayerObject . Players . PlayerAdded : Connect ( function ( Player ) Aviation . Await () --// Await is used to make sure that Aviation has begin operating local PlayerObject = Aviation . new ( Player , \"Secured-RemoteObject\" ) --// CREATION OF REMOTEOBJECTS \\\\-- PlayerObject : Process () end ) Creating RemoteObject Now that we have our PlayerObject , we can begin creating remotes which should be done before processing PlayerObject:Process() the PlayerObject . The method demonstrated below is a primitive method, and is not recommended to be used directly but it is important to learn how Aviation functions in order to properly use it. Later on you will learn about a more efficient method at creating RemoteObjects and attaching functions to them. The :NewRemote() method takes the Remote's name as argument and returns a RemoteObject, which functions can be attached to. The code below assumes that you're using the codes above to create the PlayerObject . local FriedaRemote = PlayerObject : NewRemote ( \"FriedaRemote\" ) PlayerObject : Process () Attaching Functions Not all RemoteObjects will have functions attached to them as some will be used to Invoke the client. The method demonstrated is a primitive way to attach functions to remotes is not very efficient when used as such but it can still be used sometimes. :BindToServer() methods takes in a function and feed it the Player as the first argument, and all the arguments provided by the client. RemoteObjects are two way communication devices, meaning they can return data back to the client. All functions MUST be attached to their RemoteObjects before processing the PlayerObject . local FriedaRemote = PlayerObject : NewRemote ( \"FriedaRemote\" ) FriedaRemote : BindToServer ( function ( Player , ...) print ( \"Frieda Remote was invoked by \" .. Player . Name , ...) return true end ) PlayerObject : Process () Create & Attach The way to create RemoteObjects and attach functions to them below is the most efficient and recommended way. RemoteList is a table, you can have create RemoteObjects and attach functions to them all in a module and provide it to the PlayerObject to consume. The :FromList() method takes the RemoteList as argument and construct RemoteObjects based on the list provided and should be called before processing the PlayerObject. The RemoteList is a table\"Dictionary\", all the indexes are RemoteObject's name and values are functions that are going to call when the RemoteObject is fired, which is an optional field. local RemoteList = { FriedaRemote = function ( Player , ...) print ( \"Frieda Remote was invoked by \" .. Player . Name , ...) return true end ); \"Messenger\" } Players . PlayerAdded : Connect ( function ( Player ) Aviation . Await () --// Await is used to make sure that Aviation has begin operating local PlayerObject = Aviation . new ( Player , \"Secured-RemoteObject\" ) PlayerObject : FromList ( RemoteList ) PlayerObject : Process () end ) Fire all Client Firing a specific Client on the Server needs a player from which you'll retrive the PlayerStructure and call the :FireClient method on. The :FireClient method does not consume a Player. What about firing all the Remotes of a Player? The :FireAll method is called directly on Aviation and takes the RemoteObject name that is to be fired as first argument and the rest of the arguments are passed. This method returns a table of all the PlayerResponces if there were any. How the PlayerResponces is structured, {PlayerName = {Data, Data, ...}} . local Aviation = require ( ReplicatedStorage : WaitForChild ( \"Aviation\" )) local PlayerResponces = Aviation : FireAll ( \"Messenger\" , \"Hello world from Aviation!\" ) print ( \"Frieda responded with\" , table.unpack ( PlayerResponces [ \"Frieda_VI\" ]))","title":"Server"},{"location":"pages/Api/Server/#server-functions-of-aviation","text":"","title":"Server Functions of Aviation"},{"location":"pages/Api/Server/#basic-configuration","text":"Server scripts using Aviation should require and .await() until it starts. You would usually want to dedicate an entire server script just for the creation of RemoteObjects and in that script, you should call the .Start() method on Aviation . --// Aviation runner dedicated to creating RemoteEvents \\\\-- local Players = game : GetService ( \"Players\" ) local ReplicatedStorage = game : GetService ( \"ReplicatedStorage\" ) local Aviation = require ( ReplicatedStorage : WaitForChild ( \"Aviation\" )) Aviation . Start () The .Start() method should only be called ONCE by a ServerScript. It's meant to initialise core compoenents of Aviation and to get it to run thus marking it's name to start . --// Random Server Script \\\\-- local Aviation = require ( ReplicatedStorage : WaitForChild ( \"Aviation\" )) Aviation . Await () All ServerScripts using Aviation SHOULD call the .Await() function on Aviation to ensure that everything has been correctly loaded. The Await method will yield until the Start method has been called on Aviation by a ServerScript.","title":"Basic Configuration"},{"location":"pages/Api/Server/#remoteobject-creation","text":"RemoteObjects are two way conversation objects meaning they inherrit from RemoteFunctions directly. The creation of RemoteObjects should be wrapped by the .PlayerAdded event, and it is one of the most important features that the Server provides.The examples below assumes that we are using the code above demonstrating how to start Aviation In order to creat RemoteObjects, we need an AviationObject on which RemoteObject creation can be performed.","title":"RemoteObject Creation"},{"location":"pages/Api/Server/#aviationobject-creation","text":"Aviation.new() takes 2 arguments, the Player and an optional argument which consists of the Remote name that will be used by all the RemoteFunction instance. The Aviation constructor ( Aviation.new() ) returns an AviationObject(PlayerObject). Right after creating and attaching functions to the AviationObject | PlayerObject , you're required to call the :Process() method on the AviationObject to ensure that it's processed and can used by the client. Since the AviationObject is dedicated to a Player, we can call it a PlayerObject . Players . PlayerAdded : Connect ( function ( Player ) Aviation . Await () --// Await is used to make sure that Aviation has begin operating local PlayerObject = Aviation . new ( Player , \"Secured-RemoteObject\" ) --// CREATION OF REMOTEOBJECTS \\\\-- PlayerObject : Process () end )","title":"AviationObject Creation"},{"location":"pages/Api/Server/#creating-remoteobject","text":"Now that we have our PlayerObject , we can begin creating remotes which should be done before processing PlayerObject:Process() the PlayerObject . The method demonstrated below is a primitive method, and is not recommended to be used directly but it is important to learn how Aviation functions in order to properly use it. Later on you will learn about a more efficient method at creating RemoteObjects and attaching functions to them. The :NewRemote() method takes the Remote's name as argument and returns a RemoteObject, which functions can be attached to. The code below assumes that you're using the codes above to create the PlayerObject . local FriedaRemote = PlayerObject : NewRemote ( \"FriedaRemote\" ) PlayerObject : Process ()","title":"Creating RemoteObject"},{"location":"pages/Api/Server/#attaching-functions","text":"Not all RemoteObjects will have functions attached to them as some will be used to Invoke the client. The method demonstrated is a primitive way to attach functions to remotes is not very efficient when used as such but it can still be used sometimes. :BindToServer() methods takes in a function and feed it the Player as the first argument, and all the arguments provided by the client. RemoteObjects are two way communication devices, meaning they can return data back to the client. All functions MUST be attached to their RemoteObjects before processing the PlayerObject . local FriedaRemote = PlayerObject : NewRemote ( \"FriedaRemote\" ) FriedaRemote : BindToServer ( function ( Player , ...) print ( \"Frieda Remote was invoked by \" .. Player . Name , ...) return true end ) PlayerObject : Process ()","title":"Attaching Functions"},{"location":"pages/Api/Server/#create-attach","text":"The way to create RemoteObjects and attach functions to them below is the most efficient and recommended way. RemoteList is a table, you can have create RemoteObjects and attach functions to them all in a module and provide it to the PlayerObject to consume. The :FromList() method takes the RemoteList as argument and construct RemoteObjects based on the list provided and should be called before processing the PlayerObject. The RemoteList is a table\"Dictionary\", all the indexes are RemoteObject's name and values are functions that are going to call when the RemoteObject is fired, which is an optional field. local RemoteList = { FriedaRemote = function ( Player , ...) print ( \"Frieda Remote was invoked by \" .. Player . Name , ...) return true end ); \"Messenger\" } Players . PlayerAdded : Connect ( function ( Player ) Aviation . Await () --// Await is used to make sure that Aviation has begin operating local PlayerObject = Aviation . new ( Player , \"Secured-RemoteObject\" ) PlayerObject : FromList ( RemoteList ) PlayerObject : Process () end )","title":"Create &amp; Attach"},{"location":"pages/Api/Server/#fire-all-client","text":"Firing a specific Client on the Server needs a player from which you'll retrive the PlayerStructure and call the :FireClient method on. The :FireClient method does not consume a Player. What about firing all the Remotes of a Player? The :FireAll method is called directly on Aviation and takes the RemoteObject name that is to be fired as first argument and the rest of the arguments are passed. This method returns a table of all the PlayerResponces if there were any. How the PlayerResponces is structured, {PlayerName = {Data, Data, ...}} . local Aviation = require ( ReplicatedStorage : WaitForChild ( \"Aviation\" )) local PlayerResponces = Aviation : FireAll ( \"Messenger\" , \"Hello world from Aviation!\" ) print ( \"Frieda responded with\" , table.unpack ( PlayerResponces [ \"Frieda_VI\" ]))","title":"Fire all Client"},{"location":"pages/Api/ServerClient/","text":"Shares Functions What are Shared Functions Shared functions are those functions which are available on both the Server and the Client but they might not function the same. Await The .Await() method is an incontournable function which can be used by the Server or Client. To avoid errors, you should ALWAYS use the .Await() before making your first reference to functions concerning Aviation. local Aviation = require ( ReplicatedStorage : WaitForChild ( \"Aviation\" )) Aviation . Await () Retriving PlayerObject To obtain the PlayerObject on another ServerScript that's not the Runtime or a LocalScript, we use .Structure() on Aviation. Since the PlayerObject has lost some of it's core functionality, we can call it PlayerStructure . Server Client local Aviation = require ( ReplicatedStorage : WaitForChild ( \"Aviation\" )) local PlayerStructure = Aviation . Structure ( Player ) -- The Player must be provided local Aviation = require ( ReplicatedStorage : WaitForChild ( \"Aviation\" )) local PlayerStructure = Aviation . Structure () -- Will yield unless if you send a false as argument local PlayerStructure1 = Aviation . Structure ( false ) Getting RemoteObject The :HasRemote is a method than can be called on the PlayerObject to ensure that a certain RemoteObject is present or not. HasRemote takes the argument of the RemteObject name and returns a boolean confirming wether the RemoteObject exists or not. This function can be used on both the initial PlayerObject or the PlayerStructure . The :GetRemote() method takes the RemoteObject's name as argument and returns the RemoteObject. This code can be used by both the Server (initial runtime or random ServerScript) and the Client. local PlayerStructure = Aviation . GetStructure ( Player ) local Messenger = PlayerStructure : GetRemote ( \"Messenger\" ) local FriedaRemote = PlayerStructure : GetRemote ( \"FriedaRemote\" ) Firing the Server | Client Firing the Server or Client is as simple as saying RemoteObject:FireClient(Args) or RemoteObject:FireServer(Args) , the fire methods can be given any arguments and will return data sent by the Server|Client. The :FireClient() method does NOT need the Player to be sent as argument. Server local ReplicatedStorage = game : GetService ( \"ReplicatedStorage\" ) local Aviation = require ( ReplicatedStorage : WaitForChild ( \"Aviation\" )) Aviation . Await () local PlayerStructure = Aviation . Structure ( Player ) -- The Player local ClientReply = PlayerStructure : GetRemote ( \"Messenger\" ): FireClient ( \"Hello world from Aviation!\" ) print ( \"The Client Said\" , ClientReply ) Client local ReplicatedStorage = game : GetService ( \"ReplicatedStorage\" ) local Aviation = require ( ReplicatedStorage : WaitForChild ( \"Aviation\" )) Aviation . Await () local PlayerStructure = Aviation . Structure () PlayerStructure : Securise () PlayerStructure : GetRemote ( \"FriedaRemote\" ): FireServer ( \"Is it fun?\" ) -- Can return a Value","title":"Server and Client"},{"location":"pages/Api/ServerClient/#shares-functions","text":"What are Shared Functions Shared functions are those functions which are available on both the Server and the Client but they might not function the same.","title":"Shares Functions"},{"location":"pages/Api/ServerClient/#await","text":"The .Await() method is an incontournable function which can be used by the Server or Client. To avoid errors, you should ALWAYS use the .Await() before making your first reference to functions concerning Aviation. local Aviation = require ( ReplicatedStorage : WaitForChild ( \"Aviation\" )) Aviation . Await ()","title":"Await"},{"location":"pages/Api/ServerClient/#retriving-playerobject","text":"To obtain the PlayerObject on another ServerScript that's not the Runtime or a LocalScript, we use .Structure() on Aviation. Since the PlayerObject has lost some of it's core functionality, we can call it PlayerStructure . Server Client local Aviation = require ( ReplicatedStorage : WaitForChild ( \"Aviation\" )) local PlayerStructure = Aviation . Structure ( Player ) -- The Player must be provided local Aviation = require ( ReplicatedStorage : WaitForChild ( \"Aviation\" )) local PlayerStructure = Aviation . Structure () -- Will yield unless if you send a false as argument local PlayerStructure1 = Aviation . Structure ( false )","title":"Retriving PlayerObject"},{"location":"pages/Api/ServerClient/#getting-remoteobject","text":"The :HasRemote is a method than can be called on the PlayerObject to ensure that a certain RemoteObject is present or not. HasRemote takes the argument of the RemteObject name and returns a boolean confirming wether the RemoteObject exists or not. This function can be used on both the initial PlayerObject or the PlayerStructure . The :GetRemote() method takes the RemoteObject's name as argument and returns the RemoteObject. This code can be used by both the Server (initial runtime or random ServerScript) and the Client. local PlayerStructure = Aviation . GetStructure ( Player ) local Messenger = PlayerStructure : GetRemote ( \"Messenger\" ) local FriedaRemote = PlayerStructure : GetRemote ( \"FriedaRemote\" )","title":"Getting RemoteObject"},{"location":"pages/Api/ServerClient/#firing-the-server-client","text":"Firing the Server or Client is as simple as saying RemoteObject:FireClient(Args) or RemoteObject:FireServer(Args) , the fire methods can be given any arguments and will return data sent by the Server|Client. The :FireClient() method does NOT need the Player to be sent as argument. Server local ReplicatedStorage = game : GetService ( \"ReplicatedStorage\" ) local Aviation = require ( ReplicatedStorage : WaitForChild ( \"Aviation\" )) Aviation . Await () local PlayerStructure = Aviation . Structure ( Player ) -- The Player local ClientReply = PlayerStructure : GetRemote ( \"Messenger\" ): FireClient ( \"Hello world from Aviation!\" ) print ( \"The Client Said\" , ClientReply ) Client local ReplicatedStorage = game : GetService ( \"ReplicatedStorage\" ) local Aviation = require ( ReplicatedStorage : WaitForChild ( \"Aviation\" )) Aviation . Await () local PlayerStructure = Aviation . Structure () PlayerStructure : Securise () PlayerStructure : GetRemote ( \"FriedaRemote\" ): FireServer ( \"Is it fun?\" ) -- Can return a Value","title":"Firing the Server | Client"},{"location":"pages/Shared/FileReport/","text":"Problems, Bugs or Errors? If ever you come across some bugs, please file an issue , and if the problem was still not fixed then please direct message me on Discord or Twitter . If ever you came across an error, the best way to get it fixed within the hours is to Direct Message me on Discord. GitHub Repo Discord: Frieda_VI#9522, DiscordID: 870241483431751751 \u00a9 Aviation was brought to you by Frieda_VI. 2022","title":"Need Help?"},{"location":"pages/Shared/FileReport/#problems-bugs-or-errors","text":"If ever you come across some bugs, please file an issue , and if the problem was still not fixed then please direct message me on Discord or Twitter . If ever you came across an error, the best way to get it fixed within the hours is to Direct Message me on Discord. GitHub Repo Discord: Frieda_VI#9522, DiscordID: 870241483431751751 \u00a9 Aviation was brought to you by Frieda_VI. 2022","title":"Problems, Bugs or Errors?"},{"location":"pages/Shared/Installation/","text":"Installation Installation Process Aviation supports both the Roblox Studio and Rojo workflows. It is quite simple and straight forward to install Aviation. NOTE Aviation should always be in ReplicatedStorage and the names of the files should NEVER changed. Visual Studio Code and ROJO Workflow: Download the Aviation folder. Insert Aviation to your project in Visual Studio Code. Point Aviation to ReplicatedStorage using ROJO. Roblox Studio Get the Aviation model on Roblox. Place the Aviation model in ReplicatedStorage.","title":"Installation"},{"location":"pages/Shared/Installation/#installation","text":"","title":"Installation"},{"location":"pages/Shared/Installation/#installation-process","text":"Aviation supports both the Roblox Studio and Rojo workflows. It is quite simple and straight forward to install Aviation. NOTE Aviation should always be in ReplicatedStorage and the names of the files should NEVER changed. Visual Studio Code and ROJO Workflow: Download the Aviation folder. Insert Aviation to your project in Visual Studio Code. Point Aviation to ReplicatedStorage using ROJO. Roblox Studio Get the Aviation model on Roblox. Place the Aviation model in ReplicatedStorage.","title":"Installation Process"},{"location":"pages/Shared/Tour/","text":"Tour to Aviation Contains a concrete example of Aviation and how to properly use it on the Client and the Server. The examples below do not demonstrate it's full usage and functions but just a quick overview of how you'd use it. Server Code Demonstrates the usage of RemoteObjects, creation of RemoteObjects, binding functions to them and the usage of signals. --// Aviation Remote Server RunTime \\\\-- local Players = game : GetService ( \"Players\" ) local ReplicatedStorage = game : GetService ( \"ReplicatedStorage\" ) local Aviation = require ( ReplicatedStorage : WaitForChild ( \"Aviation\" )) local Signal = Aviation . Signal Aviation . Start () --// Should be called ONLY one time local FriedaSignal = Signal . Wrap ( function ( Message ) --// Creates a signal and feeds it a function print ( Message ) end ) --// Remote list can just be in a Module, containing all the Remotes --// It helps to create multiple remotes at 1 time local RemoteList = { -- NAME: FUNCTION FriedaRemote = function ( Player , CustomMessage ) FriedaSignal : Fire ( CustomMessage ) end ; \"Messenger\" } Players . PlayerAdded : Connect ( function ( Player ) Aviation . Await () -- Everything is loaded local PlayerObject = Aviation . new ( Player , \"Relative~Remote~Name\" ) PlayerObject : FromList ( RemoteList ) PlayerObject : Process () --// MUST Process after remotes are created task . wait ( 5 ) local ClientReply = PlayerObject : GetRemote ( \"Messenger\" ): FireClient ( \"Hello world from Aviation!\" ) print ( \"The Client Said\" , ClientReply ) end ) Client Code Demonstrate how to use Aviation on the client. Uses :Securise which helps to make your RemoteObjects exploit prof and not changable. Features used in the Client Code: Securising RemoteObjects. RemoteObject and attaching functions to them. Firing RemoteObject. --// Main Client Runtime \\\\-- local Players = game : GetService ( \"Players\" ) local ReplicatedStorage = game : GetService ( \"ReplicatedStorage\" ) local Aviation = require ( ReplicatedStorage : WaitForChild ( \"Aviation\" )) Aviation . Await () local PlayerStructure = Aviation . Structure () PlayerStructure : Securise () -- To be run once on the main Client runtime PlayerStructure : FromStructure { Messenger = function ( Message ) print ( Message ) return \"Woah, that's interesting!\" end , } PlayerStructure : GetRemote ( \"FriedaRemote\" ): FireServer ( \"Is it fun?\" )","title":"Tour to Aviation"},{"location":"pages/Shared/Tour/#tour-to-aviation","text":"","title":"Tour to Aviation"},{"location":"pages/Shared/Tour/#contains-a-concrete-example-of-aviation-and-how-to-properly-use-it-on-the-client-and-the-server","text":"The examples below do not demonstrate it's full usage and functions but just a quick overview of how you'd use it. Server Code Demonstrates the usage of RemoteObjects, creation of RemoteObjects, binding functions to them and the usage of signals. --// Aviation Remote Server RunTime \\\\-- local Players = game : GetService ( \"Players\" ) local ReplicatedStorage = game : GetService ( \"ReplicatedStorage\" ) local Aviation = require ( ReplicatedStorage : WaitForChild ( \"Aviation\" )) local Signal = Aviation . Signal Aviation . Start () --// Should be called ONLY one time local FriedaSignal = Signal . Wrap ( function ( Message ) --// Creates a signal and feeds it a function print ( Message ) end ) --// Remote list can just be in a Module, containing all the Remotes --// It helps to create multiple remotes at 1 time local RemoteList = { -- NAME: FUNCTION FriedaRemote = function ( Player , CustomMessage ) FriedaSignal : Fire ( CustomMessage ) end ; \"Messenger\" } Players . PlayerAdded : Connect ( function ( Player ) Aviation . Await () -- Everything is loaded local PlayerObject = Aviation . new ( Player , \"Relative~Remote~Name\" ) PlayerObject : FromList ( RemoteList ) PlayerObject : Process () --// MUST Process after remotes are created task . wait ( 5 ) local ClientReply = PlayerObject : GetRemote ( \"Messenger\" ): FireClient ( \"Hello world from Aviation!\" ) print ( \"The Client Said\" , ClientReply ) end ) Client Code Demonstrate how to use Aviation on the client. Uses :Securise which helps to make your RemoteObjects exploit prof and not changable. Features used in the Client Code: Securising RemoteObjects. RemoteObject and attaching functions to them. Firing RemoteObject. --// Main Client Runtime \\\\-- local Players = game : GetService ( \"Players\" ) local ReplicatedStorage = game : GetService ( \"ReplicatedStorage\" ) local Aviation = require ( ReplicatedStorage : WaitForChild ( \"Aviation\" )) Aviation . Await () local PlayerStructure = Aviation . Structure () PlayerStructure : Securise () -- To be run once on the main Client runtime PlayerStructure : FromStructure { Messenger = function ( Message ) print ( Message ) return \"Woah, that's interesting!\" end , } PlayerStructure : GetRemote ( \"FriedaRemote\" ): FireServer ( \"Is it fun?\" )","title":"Contains a concrete example of Aviation and how to properly use it on the Client and the Server."},{"location":"pages/Utils/Signals/","text":"Signal Signals allows you to have your own customised version of Roblox events which can receive callback functions. Signals works on both the Client and the Server and should be kept to the code where it was created. local Signals = Aviation . Signal local mySignal = Signals . new () mySignal : Connect ( function ( Message ) print ( Message ) end ) mySignal : Fire ( \"Aviation signals are pog!\" ) Creating Signals Signal.new() is the signal constructor which doesn't take any arguments and returns a SignalObject on which Callback functions can be attached. local mySignal = Signal . new () Constructs a new Signal that wraps a function and returns a SignalObject, the SignalObject can then be mounted with more callback functions. Not that Wrap should only be called once, as it will create a new SignalObject. local myConnection = Signal . Wrap ( function ( Message ) print ( Message ) end ) Destroying Signals SignalObjects have a :Destroy() method which will disconnect all the attached functions to the Signal and will attempt to clear the Signal. Thus rendering the following signal useless. myConnection : Destroy () Attaching Functions Functions can be attached to Signals, very simply. :Connect() takes in a callback function which will be call when a Signal is fired. Callback functions are allowed to yield and multiple callback functions can be attached to a SignalObject. myConnection : Connect ( function ( Message ) print ( Message ) end ) myConnection : Connect ( function ( Message ) StringValue . Value = tostring ( Message ) end ) Fire Signals There are 3 ways of firing signals. Well be taking the myConnection for example. Fire The default :Fire() function yields by default. myConnection : Fire ( \"Hello world\" ) FireSpawn The :FireSpawn() function doesn't yield and uses task.spawn , which creates a new thread. myConnection : FireSpawn ( \"Hello world\" ) FireDefer The :FireDefer() function doesn't yield and uses task.defer , which can be used to achive a similar behaviour to :FireSpawn . myConnection : FireDefer ( \"Hello world\" ) Signal Checking Helps to check wether an object is a SignalObject or not. local Signal = Aviation . Signal Vider . IsSignal ( myVider ) --> Proves wether object is a SignalObject or not: boolean","title":"Signals"},{"location":"pages/Utils/Signals/#signal","text":"Signals allows you to have your own customised version of Roblox events which can receive callback functions. Signals works on both the Client and the Server and should be kept to the code where it was created. local Signals = Aviation . Signal local mySignal = Signals . new () mySignal : Connect ( function ( Message ) print ( Message ) end ) mySignal : Fire ( \"Aviation signals are pog!\" )","title":"Signal"},{"location":"pages/Utils/Signals/#creating-signals","text":"Signal.new() is the signal constructor which doesn't take any arguments and returns a SignalObject on which Callback functions can be attached. local mySignal = Signal . new () Constructs a new Signal that wraps a function and returns a SignalObject, the SignalObject can then be mounted with more callback functions. Not that Wrap should only be called once, as it will create a new SignalObject. local myConnection = Signal . Wrap ( function ( Message ) print ( Message ) end )","title":"Creating Signals"},{"location":"pages/Utils/Signals/#destroying-signals","text":"SignalObjects have a :Destroy() method which will disconnect all the attached functions to the Signal and will attempt to clear the Signal. Thus rendering the following signal useless. myConnection : Destroy ()","title":"Destroying Signals"},{"location":"pages/Utils/Signals/#attaching-functions","text":"Functions can be attached to Signals, very simply. :Connect() takes in a callback function which will be call when a Signal is fired. Callback functions are allowed to yield and multiple callback functions can be attached to a SignalObject. myConnection : Connect ( function ( Message ) print ( Message ) end ) myConnection : Connect ( function ( Message ) StringValue . Value = tostring ( Message ) end )","title":"Attaching Functions"},{"location":"pages/Utils/Signals/#fire-signals","text":"There are 3 ways of firing signals. Well be taking the myConnection for example.","title":"Fire Signals"},{"location":"pages/Utils/Signals/#fire","text":"The default :Fire() function yields by default. myConnection : Fire ( \"Hello world\" )","title":"Fire"},{"location":"pages/Utils/Signals/#firespawn","text":"The :FireSpawn() function doesn't yield and uses task.spawn , which creates a new thread. myConnection : FireSpawn ( \"Hello world\" )","title":"FireSpawn"},{"location":"pages/Utils/Signals/#firedefer","text":"The :FireDefer() function doesn't yield and uses task.defer , which can be used to achive a similar behaviour to :FireSpawn . myConnection : FireDefer ( \"Hello world\" )","title":"FireDefer"},{"location":"pages/Utils/Signals/#signal-checking","text":"Helps to check wether an object is a SignalObject or not. local Signal = Aviation . Signal Vider . IsSignal ( myVider ) --> Proves wether object is a SignalObject or not: boolean","title":"Signal Checking"},{"location":"pages/Utils/Vider/","text":"Vider Vider is a janitor module that uses french terms. It's recommended to avoid using Vider directly in your game as it's specific to Aviation. You could clone Vider and place it in ReplicatedStorage to use it. Constructor Vider.new() is the vider constructor which doesn't take any arguments and return a ViderObject. It is recommended to use Vider:Debute() instead of Vider.new() , Debute takes it a MainInstance and other which are considered as secondary instances. If the MainInstance is destroyed, it will trigger Vider:Nettoyer which is the cleaning up method. Other can only be RBXScriptConnection or Instances. Debute returns a ViderObject with the MainInstance as the controller and other arguments as secondary objects. local Vider = Aviation . Vider local myVider = Vider : Debute ( workspace . Baseplate , workspace . Changed : Connect ( function ( Child ) print ( Child ) end ), workspace . Part ) -- Vider only works with Instances Adding MainInstance You can have more than 1 MainInstance in your ViderObject, if a MainInstance is destroyed, all the secondary objects will be destroyed but the MainInstances wouldn't be destroyed by default. We use the :AjouteMain method on our ViderObject to add a MainInstance. myVider : AjouteMain ( workspace ) Adding SecondaryInstance Just like you can add MainInstances, you can also add more SecondaryInstance which will be Destroyed|Disconnected when nettoyer is called. myVider : AjouteAutre ( workspace . Part1 , workspace . Part2 , game . Players . PlayerAdded : Connect ( function ( Player ) print ( \"A new player has joined the game!\" ) end )) Cleaning ViderObjects will manually undergo the cleaning process after a MainInstance is destroyed but it is possible to force clean the ViderObject. The :Nettoyer method is called on the ViderObject will forcefully clean the the SecondaryInstance by default but if the boolean true is passed as argument, the MainInstances will also be destroyed. myVider : Nettoyer () -- Main Instance won't be destroy myVider : Nettoyer ( true ) -- Main Instances will be destroyed Cleaning Functions There are 2 functions which are charged to run before and after cleaning. :AvantNet method takes a callback function as argument and it will be call before cleaning the Instances, there can only be 1 AvantNet function. myVider : AvantNet ( function () print ( \"Cleaning process has been triggered\" ) mySignal : Destroy () -- Perfect location to Destroy SignalObjects end ) :ApresNet method takes a callback function as argument and it will be call after cleaning the Instances, there can only be 1 ApresNet function. myVider : ApresNet ( function () print ( \"Cleaning process has been completed\" ) end ) SignalObject will be compatible to Vider in the next update. Vider Checking Helps to check wether an object is a ViderObject or not. local Vider = Aviation . Vider Vider . IsVider ( myVider ) --> Proves wether object is a ViderObject or not: boolean","title":"Vider"},{"location":"pages/Utils/Vider/#vider","text":"Vider is a janitor module that uses french terms. It's recommended to avoid using Vider directly in your game as it's specific to Aviation. You could clone Vider and place it in ReplicatedStorage to use it.","title":"Vider"},{"location":"pages/Utils/Vider/#constructor","text":"Vider.new() is the vider constructor which doesn't take any arguments and return a ViderObject. It is recommended to use Vider:Debute() instead of Vider.new() , Debute takes it a MainInstance and other which are considered as secondary instances. If the MainInstance is destroyed, it will trigger Vider:Nettoyer which is the cleaning up method. Other can only be RBXScriptConnection or Instances. Debute returns a ViderObject with the MainInstance as the controller and other arguments as secondary objects. local Vider = Aviation . Vider local myVider = Vider : Debute ( workspace . Baseplate , workspace . Changed : Connect ( function ( Child ) print ( Child ) end ), workspace . Part ) -- Vider only works with Instances","title":"Constructor"},{"location":"pages/Utils/Vider/#adding-maininstance","text":"You can have more than 1 MainInstance in your ViderObject, if a MainInstance is destroyed, all the secondary objects will be destroyed but the MainInstances wouldn't be destroyed by default. We use the :AjouteMain method on our ViderObject to add a MainInstance. myVider : AjouteMain ( workspace )","title":"Adding MainInstance"},{"location":"pages/Utils/Vider/#adding-secondaryinstance","text":"Just like you can add MainInstances, you can also add more SecondaryInstance which will be Destroyed|Disconnected when nettoyer is called. myVider : AjouteAutre ( workspace . Part1 , workspace . Part2 , game . Players . PlayerAdded : Connect ( function ( Player ) print ( \"A new player has joined the game!\" ) end ))","title":"Adding SecondaryInstance"},{"location":"pages/Utils/Vider/#cleaning","text":"ViderObjects will manually undergo the cleaning process after a MainInstance is destroyed but it is possible to force clean the ViderObject. The :Nettoyer method is called on the ViderObject will forcefully clean the the SecondaryInstance by default but if the boolean true is passed as argument, the MainInstances will also be destroyed. myVider : Nettoyer () -- Main Instance won't be destroy myVider : Nettoyer ( true ) -- Main Instances will be destroyed","title":"Cleaning"},{"location":"pages/Utils/Vider/#cleaning-functions","text":"There are 2 functions which are charged to run before and after cleaning. :AvantNet method takes a callback function as argument and it will be call before cleaning the Instances, there can only be 1 AvantNet function. myVider : AvantNet ( function () print ( \"Cleaning process has been triggered\" ) mySignal : Destroy () -- Perfect location to Destroy SignalObjects end ) :ApresNet method takes a callback function as argument and it will be call after cleaning the Instances, there can only be 1 ApresNet function. myVider : ApresNet ( function () print ( \"Cleaning process has been completed\" ) end ) SignalObject will be compatible to Vider in the next update.","title":"Cleaning Functions"},{"location":"pages/Utils/Vider/#vider-checking","text":"Helps to check wether an object is a ViderObject or not. local Vider = Aviation . Vider Vider . IsVider ( myVider ) --> Proves wether object is a ViderObject or not: boolean","title":"Vider Checking"}]}